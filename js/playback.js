/**
 * Playback module - Video playback control for IPTVApp
 * Handles seeking, playback controls, track selection, external subtitles
 */

// Format duration as "1h30" or "45min" if less than 1h
IPTVApp.prototype.formatDuration = function(ms) {
    var totalMinutes = Math.floor(ms / 60000);
    var h = Math.floor(totalMinutes / 60);
    var m = totalMinutes % 60;
    if (h === 0) {
        return m + I18n.t('player.minShort');
    }
    var hourLabel = I18n.t('player.hourShort');
    var minStr = m > 0 ? (m < 10 ? '0' + m : m) : '';
    return h + hourLabel + minStr;
};

// Seek controls
IPTVApp.prototype.startSeek = function(direction) {
    window.log('ACTION startSeek: ' + (direction > 0 ? 'forward' : 'backward'));
    var self = this;
    var hadPendingSeek = !!this.seekDebounceTimer;
    if (this.seekDebounceTimer) {
        clearTimeout(this.seekDebounceTimer);
        this.seekDebounceTimer = null;
    }
    var isLive = this.currentPlayingType === 'live';
    var isCatchup = this.currentPlayingType === 'catchup' && this.catchupParams;
    var hasContent = this.player.duration > 0 || isCatchup;
    // No seeking for live streams
    if (isLive || !hasContent) {
        return;
    }
    if (this.seekDirection === direction && this.seekInterval) {
        // Reset safety timeout on repeated keydown (key held)
        if (this.seekSafetyTimeout) {
            clearTimeout(this.seekSafetyTimeout);
        }
        this.seekSafetyTimeout = setTimeout(function() {
            self.stopSeek();
        }, 500);
        return;
    }
    if (this.seekDirection !== 0 && this.seekDirection !== direction) {
        this.stopSeek();
    }
    if (!hadPendingSeek) {
        this.wasPlaying = this.player.isPlaying && !this.player.isPaused;
        if (this.wasPlaying) {
            this.player.pause();
        }
    }
    this.seekDirection = direction;
    this.seekStartTime = Date.now();
    // Detect if this is a new isolated seek session (> 1s since last seek action)
    var isNewSeekSession = (this.seekStartTime - this.lastSeekActionTime) > 1000;
    this.lastSeekActionTime = this.seekStartTime;
    this.isFirstBackwardTick = (direction === -1 && isNewSeekSession);
    // seekTargetPosition is already set: either from playStream start or from updatePlayerProgress
    this.updateSeekPreview();
    this.showPlayerOverlay();
    this.seekInterval = setInterval(function() {
        self.updateSeekPreview();
        self.showPlayerOverlay();
    }, 250);
};

IPTVApp.prototype.getSeekMultiplier = function() {
    var elapsed = Date.now() - this.seekStartTime;
    var index = 0;
    if (elapsed > 5000) index = 5;
    else if (elapsed > 4000) index = 4;
    else if (elapsed > 3000) index = 3;
    else if (elapsed > 2000) index = 2;
    else if (elapsed > 1000) index = 1;
    return this.seekMultipliers[index];
};

IPTVApp.prototype.updateSeekPreview = function() {
    var multiplier = this.getSeekMultiplier();
    // Use 5s only for the first tick of an isolated backward seek, otherwise 10s
    var baseJump = this.seekBaseJump;
    if (this.isFirstBackwardTick) {
        baseJump = this.seekFirstBackwardJump;
        this.isFirstBackwardTick = false;
    }
    var jumpMs = baseJump * multiplier * 1000 * this.seekDirection;
    // For catchup: use program duration instead of player duration
    var isCatchup = this.currentPlayingType === 'catchup' && this.catchupParams;
    var duration = isCatchup ? (this.catchupParams.duration * 60 * 1000 + 60000) : this.player.duration;
    var oldPosition = this.seekTargetPosition;
    this.seekTargetPosition = Math.max(0, Math.min(duration, this.seekTargetPosition + jumpMs));
    // For catchup: if at start and trying to go backward, load previous program
    if (isCatchup && this.seekDirection === -1 && oldPosition === 0 && this.seekTargetPosition === 0) {
        this.seekAtStartCount = (this.seekAtStartCount || 0) + 1;
        if (this.seekAtStartCount >= 3) {
            this.seekAtStartCount = 0;
            this.stopSeek();
            this.playPrevCatchup();
            return;
        }
    }
    else {
        this.seekAtStartCount = 0;
    }
    // For catchup: display adjusted time (subtract 1 minute buffer)
    var displayPosition = isCatchup ? Math.max(0, this.seekTargetPosition - 60000) : this.seekTargetPosition;
    var displayDuration = isCatchup ? (this.catchupParams.duration * 60 * 1000) : duration;
    var percent = displayDuration > 0 ? (displayPosition / displayDuration) * 100 : 0;
    document.getElementById('progress-bar').style.width = Math.min(100, percent) + '%';
    var remaining = Math.max(0, displayDuration - displayPosition);
    document.getElementById('player-time').textContent = this.player.formatTime(displayPosition);
    document.getElementById('player-remaining').textContent = this.player.formatTime(remaining);
    this.showSeekIndicator(multiplier);
};

IPTVApp.prototype.stopSeek = function() {
    if (this.seekSafetyTimeout) {
        clearTimeout(this.seekSafetyTimeout);
        this.seekSafetyTimeout = null;
    }
    if (this.seekInterval) {
        clearInterval(this.seekInterval);
        this.seekInterval = null;
    }
    if (this.seekDirection !== 0) {
        var self = this;
        var targetPos = this.seekTargetPosition;
        var wasPlaying = this.wasPlaying;
        var duration = this.player.duration;
        // If seeking past end, trigger completion instead of seeking
        if (duration > 0 && targetPos >= duration && !this._completionTriggered) {
            window.log('Seek past end: target=' + targetPos + ' duration=' + duration + ', triggering completion');
            this._completionTriggered = true;
            this.seekDirection = 0;
            this.hideSeekIndicator();
            this.onPlaybackCompleted();
            return;
        }
        if (this.seekDebounceTimer) {
            clearTimeout(this.seekDebounceTimer);
        }
        this.seekDebounceTimer = setTimeout(function() {
            self.seekDebounceTimer = null;
            if (self.seekDirection === 0) {
                self.player.seekTo(targetPos);
                self.lastSeekTime = Date.now();
                if (wasPlaying) {
                    self.player.resume();
                }
            }
        }, 150);
    }
    this.seekDirection = 0;
    this.hideSeekIndicator();
};

IPTVApp.prototype.showSeekIndicator = function(multiplier) {
    var indicator = document.getElementById('seek-indicator');
    var symbol = this.seekDirection > 0 ? '▶▶' : '◀◀';
    indicator.textContent = symbol + ' x' + multiplier;
    indicator.classList.add('visible');
};

IPTVApp.prototype.hideSeekIndicator = function() {
    var indicator = document.getElementById('seek-indicator');
    indicator.classList.remove('visible');
};


// Return to live (exit timeshift)
IPTVApp.prototype.returnToLive = function() {
    window.log('ACTION returnToLive');
    if (this.currentPlayingType !== 'live') return;
    // Reset timeshift state
    this.player.isInTimeshift = false;
    this.player.pauseStartTime = null;
    // Restart the stream to go back to live
    var stream = this.currentPlayingStream;
    var type = this.currentPlayingType;
    this.player.stop();
    this.playStream(stream.stream_id, type, stream);
};

IPTVApp.prototype.getVideoQuality = function() {
    try {
        var info = this.player.getVideoInfo();
        if (!info) return '';
        // Parse width x height from info string like "1920x1080 (16:9)"
        var match = info.match(Regex.resolution);
        if (!match) return '';
        var width = parseInt(match[1]);
        var height = parseInt(match[2]);
        // Determine quality label based on height
        var quality;
        if (height >= 2160) quality = '4K';
        else if (height >= 1440) quality = '1440p';
        else if (height >= 1080) quality = '1080p';
        else if (height >= 720) quality = '720p';
        else if (height >= 576) quality = '576p';
        else if (height >= 480) quality = '480p';
        else quality = height + 'p';
        // Add dimensions
        return quality + ' (' + width + 'x' + height + ')';
    }
    catch (ex) {
        return '';
    }
};

// Playback
IPTVApp.prototype.playStream = function(streamId, type, stream, startPosition) {
    window.log('playStream: id=' + streamId + ' type=' + type + ' section=' + this.currentSection);
    this.videoQuality = '';
    this._completionTriggered = false;
    // Reset EPG info (only relevant for live, clear for VOD/series)
    this.currentEPG = null;
    document.getElementById('player-epg').textContent = '';
    // Reset subtitles for new stream
    this.currentSubtitleIndex = -1;
    this.externalSubtitles = null;
    this.lastExternalSubtitle = null;
    this._subtitleDebugLogged = false;
    this._subtitleShownLogged = false;
    this._audioAutoSelected = false;
    this.currentAudioIndex = 0;
    if (this.player) {
        this.player.hideSubtitles();
        // Reset playback speed to normal
        this.player.playbackSpeed = 1;
        // Set buffering timeout (30 seconds)
        this.player.setBufferingTimeout(30000);
    }
    this.updateSpeedLabel();
    // Reset tmdbInfo only for content types without TMDB (live, sport)
    if (type === 'live' || type === 'sport') {
        this.tmdbInfo = null;
    }
    var url;
    if (stream && stream._m3u && stream.url) {
        url = stream.url;
    }
    else if (this.api) {
        // Use container_extension from stream data if available
        var ext = stream && stream.container_extension ? stream.container_extension : null;
        if (!ext && type !== 'live') {
            window.log('[WARN] No container_extension for type=' + type);
        }
        switch (type) {
            case 'live':
                url = this.api.getLiveStreamUrl(streamId, ext || 'ts');
                break;
            case 'vod':
                url = this.api.getVodStreamUrl(streamId, ext || 'mkv');
                break;
            case 'series':
            case 'episode':
                url = this.api.getSeriesStreamUrl(streamId, ext || 'mkv');
                break;
        }
    }
    else {
        window.log('No API and no M3U URL for stream');
        return;
    }
    window.log('playStream URL: ' + url);
    if (type !== 'live' && type !== 'episode' && stream) {
        this.addToWatchHistory(stream, type, 0);
    }
    // Increment playback ID to ignore events from previous stream
    this.currentPlaybackId = (this.currentPlaybackId || 0) + 1;
    var playbackId = this.currentPlaybackId;
    this.streamReady = false;
    this.currentPlayingStream = stream;
    this.currentPlayingType = type;
    this.seekTargetPosition = startPosition || 0;
    this.lastSeekTime = 0;
    var initialPercent = 0;
    var initialTime = '0:00';
    var initialRemaining = '0:00';
    var initialDuration = '';
    if (startPosition > 0) {
        var savedProgress = (type === 'episode') ? this.episodeProgress[streamId] : this.getWatchHistoryItem(streamId);
        if (savedProgress && savedProgress.duration > 0) {
            initialPercent = savedProgress.percent || 0;
            var remaining = Math.max(0, savedProgress.duration - startPosition);
            initialTime = this.player.formatTime(startPosition);
            initialRemaining = this.player.formatTime(remaining);
            initialDuration = this.formatDuration(savedProgress.duration);
        }
    }
    document.getElementById('progress-bar').style.width = initialPercent + '%';
    document.getElementById('player-time').textContent = initialTime;
    document.getElementById('player-remaining').textContent = initialRemaining;
    document.getElementById('player-duration').textContent = initialDuration;
    // Hide progress bar and time for live streams
    var isLive = type === 'live';
    document.getElementById('player-progress-row').style.display = isLive ? 'none' : '';
    document.getElementById('player-duration').style.display = isLive ? 'none' : '';
    var posterUrl = stream ? (stream.stream_icon || stream.cover) : null;
    this.showLoading(true, posterUrl);
    this.showScreen('player');
    this.currentScreen = 'player';
    this.focusArea = 'player';
    this.playerTracksFocused = false;
    var self = this;
    var subtitlesApplied = false;
    this.player.onStateChange = function(state) {
        if (state === 'buffering') {
            self.isBuffering = true;
            self.updatePlayerStateIndicator();
            self.showPlayerOverlay();
        }
        else if (state === 'playing') {
            self.streamReady = true;
            self.isBuffering = false;
            self.bufferPercent = undefined;
            // Manage timeshift timer
            if (self.pauseCounterInterval) {
                clearInterval(self.pauseCounterInterval);
                self.pauseCounterInterval = null;
            }
            self.videoQuality = self.getVideoQuality();
            if (!self.videoQuality) {
                setTimeout(function() {
                    var quality = self.getVideoQuality();
                    if (quality && quality !== self.videoQuality) {
                        self.videoQuality = quality;
                        self.showPlayerOverlay();
                    }
                }, 1000);
            }
            self.updatePlayerStateIndicator();
            self.showLoading(false);
            self.showPlayerOverlay();
            // Seek is now done before play() in player.js to avoid double buffering
            if (!subtitlesApplied) {
                subtitlesApplied = true;
                setTimeout(function() {
                    self.reapplySubtitleTrack();
                    self.autoEnableForcedSubtitles();
                }, 800);
            }
        }
        else if (state === 'paused') {
            self.updatePlayerStateIndicator();
            self.showPlayerOverlay();
            // Start pause counter update timer
            if (self.pauseCounterInterval) {
                clearInterval(self.pauseCounterInterval);
            }
            self.pauseCounterInterval = setInterval(function() {
                self.updatePlayerStateIndicator();
            }, 1000);
        }
        else if (state === 'error') {
            self.showLoading(false);
        }
        else if (state === 'completed') {
            self.onPlaybackCompleted();
        }
    };
    this.player.onTimeUpdate = function(current, total) {
        // Ignore events from previous stream
        if (playbackId !== self.currentPlaybackId) {
            return;
        }
        self.updatePlayerProgress(current, total);
        self.displayExternalSubtitle(current);
        if (stream && type !== 'live') {
            self.updateWatchPosition(stream, type, current);
            if (type === 'episode' || type === 'series') {
                self.updateEpisodeProgress(streamId, current, total);
            }
            else if (type === 'vod' || type === 'movie') {
                self.updateWatchHistoryProgress(streamId, current, total);
            }
        }
    };
    this.player.onError = function(error) {
        // If HTML5 player also failed, show error and go back to details
        if (error && error.html5Error) {
            self.showLoading(false);
            // Show codec error if available, otherwise generic error
            if (error.unsupportedCodec && error.codecName) {
                var resolution = '';
                if (error.width > 0 && error.height > 0) {
                    resolution = ' (' + error.width + 'x' + error.height + ')';
                }
                var msg = I18n.t('player.unsupportedCodec', { codec: error.codecName + resolution });
                if (msg === 'player.unsupportedCodec') {
                    msg = 'Codec ' + error.codecName + resolution + ' not supported by this TV';
                }
                self.showToast(msg);
            }
            else {
                self.showToast(I18n.t('player.playbackError'));
            }
            setTimeout(function() {
                self.stopPlayback();
            }, 100);
            return;
        }
        // Check for codec-specific error - try HTML5 fallback (from native)
        if (error && error.unsupportedCodec && error.codecName && !error.html5Error) {
            var resolution = '';
            if (error.width > 0 && error.height > 0) {
                resolution = ' (' + error.width + 'x' + error.height + ')';
            }
            window.log('Unsupported codec: ' + error.codecName + resolution + ' - trying HTML5 fallback');
            var tryingMsg = I18n.t('player.tryingHtml5');
            if (tryingMsg === 'player.tryingHtml5') {
                tryingMsg = 'Essai du lecteur alternatif...';
            }
            self.showToast(tryingMsg);
            // Try HTML5 fallback
            setTimeout(function() {
                self.player.playHtml5();
            }, 100);
            return;
        }
        // Check for HTML5 error - try native fallback if AVPlay available
        if (error && error.html5Error && typeof webapis !== 'undefined' && webapis.avplay) {
            window.log('HTML5 player failed - trying native AVPlay fallback');
            var tryingMsg = I18n.t('player.tryingNative');
            if (tryingMsg === 'player.tryingNative') {
                tryingMsg = 'Essai du lecteur natif...';
            }
            self.showToast(tryingMsg);
            // Try native fallback
            setTimeout(function() {
                self.player.playNative();
            }, 100);
            return;
        }
        // Generic error
        self.showLoading(false);
        self.showToast(I18n.t('player.playbackError'));
        setTimeout(function() {
            self.stopPlayback();
        }, 100);
    };
    this.player.onBufferProgress = function(percent) {
        self.bufferPercent = percent;
        self.updatePlayerStateIndicator();
    };
    // Auto-restart on freeze for live streams
    this.player.onFrozen = function() {
        if (type === 'live') {
            window.log('Live stream frozen, restarting playback...');
            self.showToast(I18n.t('player.reconnecting') || 'Reconnecting...');
            self.player.stop();
            setTimeout(function() {
                self.player.play(url, true);
            }, 1000);
        }
    };
    this.player.play(url, type === 'live', startPosition || 0);
    // Load EPG for live streams
    if (type === 'live') {
        this.loadEPG(streamId);
    }
};

IPTVApp.prototype.loadEPG = function(streamId) {
    var self = this;
    this.currentEPG = null;
    document.getElementById('player-epg').textContent = '';
    if (!this.api || !this.api.getEPG) return;
    this.api.getEPG(streamId).then(function(data) {
        if (!data || !data.epg_listings || data.epg_listings.length === 0) {
            return;
        }
        var now = Math.floor(Date.now() / 1000);
        var currentProgram = null;
        for (var i = 0; i < data.epg_listings.length; i++) {
            var prog = data.epg_listings[i];
            var start = parseInt(prog.start_timestamp, 10);
            var end = parseInt(prog.stop_timestamp, 10);
            if (now >= start && now < end) {
                currentProgram = prog;
                break;
            }
        }
        if (currentProgram) {
            try {
                // Decode base64 with UTF-8 support
                var title = decodeURIComponent(escape(atob(currentProgram.title)));
                self.currentEPG = {
                    title: title,
                    start: currentProgram.start,
                    end: currentProgram.end
                };
                document.getElementById('player-epg').textContent = title;
            }
            catch (e) {
                window.log('ERROR EPG decode: ' + e);
            }
        }
    }).catch(function(e) {
        window.log('ERROR EPG load: ' + e);
    });
};

IPTVApp.prototype.updateWatchPosition = function(stream, type, position, force) {
    var streamId = stream.stream_id || stream.series_id;
    for (var i = 0; i < this.watchHistory.length; i++) {
        if (this.watchHistory[i].id == streamId) {
            var diff = Math.abs(this.watchHistory[i].position - position);
            if (force || diff > 10000) {
                this.watchHistory[i].position = position;
                this.saveWatchHistory();
            }
            break;
        }
    }
};

IPTVApp.prototype.stopPlayback = function() {
    // Stop pause counter timer
    if (this.pauseCounterInterval) {
        clearInterval(this.pauseCounterInterval);
        this.pauseCounterInterval = null;
    }
    var wasHistory = (this.currentStreamType === 'history');
    var isSeries = this.selectedStream && this.selectedStream.type === 'series';
    if (this.currentPlayingStream && this.currentPlayingType !== 'live') {
        var currentPos = this.player.currentTime || 0;
        var duration = this.player.duration || 0;
        var streamId = this.currentPlayingStream.stream_id || this.currentPlayingStream.vod_id;
        if (currentPos > 0) {
            this.updateWatchPosition(this.currentPlayingStream, this.currentPlayingType, currentPos, true);
            if (this.currentPlayingType === 'vod' || this.currentPlayingType === 'movie') {
                this.updateWatchHistoryProgress(streamId, currentPos, duration);
            }
        }
    }
    this.currentPlayingStream = null;
    this.currentPlayingType = null;
    this.isBuffering = false;
    this.bufferPercent = undefined;
    document.getElementById('buffer-indicator').classList.add('hidden');
    this.player.stop();
    if (this.selectedStream && !wasHistory) {
        this.showScreen('details');
        this.currentScreen = 'details';
        this.focusArea = 'details';
        if (isSeries && this.currentSeason) {
            this.selectSeason(this.currentSeason);
        }
        if (isSeries && this.currentSeriesInfo) {
            this.updateSeriesContinueButton(this.currentSeriesInfo);
        }
        else if (!isSeries) {
            this.updateVodButtons();
        }
        this.updateContinueCounter();
        if (isSeries && this.launchedFromButton === 'continue') {
            // Return to continue button
            this.focusIndex = this.getDetailsPlayIndex();
            this.updateFocus();
            var wrapper = document.getElementById('details-wrapper');
            if (wrapper) wrapper.scrollTop = 0;
        }
        else if (isSeries && this.currentEpisodeId) {
            // Return to episode in list
            var self = this;
            setTimeout(function() {
                var focusables = self.getFocusables();
                self.focusIndex = 0;
                for (var i = 0; i < focusables.length; i++) {
                    if (focusables[i].dataset && focusables[i].dataset.episodeId == self.currentEpisodeId) {
                        self.focusIndex = i;
                        break;
                    }
                }
                self.updateFocus();
                // Scroll episode into view
                var episodeEl = document.querySelector('.episode-item[data-episode-id="' + self.currentEpisodeId + '"]');
                if (episodeEl) {
                    episodeEl.scrollIntoView({ block: 'center' });
                }
            }, 50);
        }
        else {
            this.focusIndex = this.getDetailsPlayIndex();
            this.updateFocus();
        }
    }
    else {
        this.showScreen('browse');
        this.currentScreen = 'browse';
        if (wasHistory) {
            this.showHistoryScreen();
        }
        this.updateContinueCounter();
        this.focusArea = 'grid';
        this.focusIndex = this.lastGridIndex || 0;
        this.updateFocus();
    }
};

IPTVApp.prototype.onPlaybackCompleted = function() {
    var self = this;
    var isSeries = this.selectedStream && this.selectedStream.type === 'series';
    if (this.currentPlayingStream && !isSeries) {
        var streamId = this.currentPlayingStream.stream_id || this.currentPlayingStream.series_id;
        // Mark as watched in watchHistory
        var historyItem = this.getWatchHistoryItem(streamId);
        if (historyItem) {
            historyItem.watched = true;
            this.saveWatchHistory();
        }
    }
    this.currentPlayingStream = null;
    this.currentPlayingType = null;
    this.isBuffering = false;
    this.bufferPercent = undefined;
    document.getElementById('buffer-indicator').classList.add('hidden');
    this.player.stop();
    if (isSeries) {
        var next = this.getNextEpisode();
        if (next) {
            if (next.season !== this.currentSeason) {
                this.currentSeason = next.season;
            }
            setTimeout(function() {
                self.playNextEpisode(next.episode);
            }, 500);
            return;
        }
        this.showScreen('details');
        this.currentScreen = 'details';
        this.focusArea = 'details';
        if (this.currentSeason) {
            this.selectSeason(this.currentSeason);
        }
        this.focusIndex = 0;
        if (this.currentEpisodeId) {
            var focusables = this.getFocusables();
            for (var i = 0; i < focusables.length; i++) {
                if (focusables[i].dataset.episodeId == this.currentEpisodeId) {
                    this.focusIndex = i;
                    break;
                }
            }
        }
        this.updateFocus();
    }
    else {
        this.showScreen('browse');
        this.currentScreen = 'browse';
        this.focusArea = 'grid';
        this.focusIndex = 0;
        this.updateFocus();
    }
};

IPTVApp.prototype.playNextEpisode = function(episode) {
    this.currentEpisodeId = episode.id;
    this.currentEpisodeNum = parseInt(episode.episode_num) || 0;
    var stream = {
        stream_id: episode.id,
        series_id: this.selectedStream.id,
        name: this.selectedStream.data.name,
        cover: this.selectedStream.data.cover || this.selectedStream.data.stream_icon,
        season: this.currentSeason,
        episode: episode.episode_num,
        episodeTitle: episode.title || (I18n.t('details.episode') + ' ' + episode.episode_num)
    };
    this.addToWatchHistory(stream, 'series', 0);
    this.playStream(episode.id, 'episode', stream);
};

// Player UI
IPTVApp.prototype.updatePlayerProgress = function(current, total) {
    if (this.seekDirection !== 0 || this.seekDebounceTimer) {
        return;
    }
    // Don't update progress for live in timeshift - handled by updatePlayerStateIndicator
    if (this.currentPlayingType === 'live' && this.player.isInTimeshift) {
        return;
    }
    // For catchup: use program duration instead of player duration (which is wrong)
    // Also adjust current time to account for the 1 minute buffer we requested
    if (this.currentPlayingType === 'catchup' && this.catchupParams) {
        var programDuration = this.catchupParams.duration * 60 * 1000;
        // Adjust display: subtract 1 minute buffer, clamp to 0
        var adjustedCurrent = Math.max(0, current - 60000);
        if (!this._catchupLogDone) {
            this._catchupLogDone = true;
            window.log('Catchup progress: current=' + current + ' adjustedCurrent=' + adjustedCurrent + ' programDuration=' + programDuration + ' duration=' + this.catchupParams.duration);
        }
        // Update seek position only when stream is ready
        if (this.streamReady) {
            this.seekTargetPosition = current;
        }
        var percent = programDuration > 0 ? (adjustedCurrent / programDuration) * 100 : 0;
        percent = Math.min(100, percent);
        document.getElementById('progress-bar').style.width = percent + '%';
        var remaining = Math.max(0, programDuration - adjustedCurrent);
        document.getElementById('player-time').textContent = this.player.formatTime(adjustedCurrent);
        document.getElementById('player-remaining').textContent = this.player.formatTime(remaining);
        var durationEl = document.getElementById('player-duration');
        if (durationEl && !durationEl.textContent) {
            durationEl.textContent = this.formatDuration(programDuration);
        }
        return;
    }
    // Update seek position only when stream is ready (avoid stale values from previous stream)
    if (this.streamReady) {
        this.seekTargetPosition = current;
    }
    var percent = total > 0 ? (current / total) * 100 : 0;
    document.getElementById('progress-bar').style.width = percent + '%';
    var remaining = Math.max(0, total - current);
    document.getElementById('player-time').textContent = this.player.formatTime(current);
    document.getElementById('player-remaining').textContent = this.player.formatTime(remaining);
    // Update duration in title if not set yet
    var durationEl = document.getElementById('player-duration');
    if (durationEl && total > 0 && !durationEl.textContent) {
        durationEl.textContent = this.formatDuration(total);
    }
    // Detect near-end after seek: if within 2 seconds of end, trigger completion
    // This handles the case where seek overshoots and player freezes
    if (total > 0 && current > 0 && (total - current) < 2000 && !this._completionTriggered) {
        window.log('Near end detected: current=' + current + ' total=' + total + ', triggering completion');
        this._completionTriggered = true;
        this.onPlaybackCompleted();
    }
};

IPTVApp.prototype.updatePlayerStateIndicator = function() {
    var stateEl = document.getElementById('player-state');
    var bufferEl = document.getElementById('buffer-indicator');
    var liveBufferEl = document.getElementById('player-buffer');
    if (!stateEl) return;
    // Buffer indicator (centered on screen, compact when speed > 1x)
    var isSpeedUp = this.player && this.player.playbackSpeed > 1;
    bufferEl.classList.toggle('compact', isSpeedUp);
    if (this.bufferPercent !== undefined && this.bufferPercent < 100) {
        bufferEl.textContent = isSpeedUp ? '⏳' : '⏳ ' + this.bufferPercent + '%';
        bufferEl.classList.remove('hidden');
    }
    else if (this.isBuffering) {
        bufferEl.textContent = '⏳';
        bufferEl.classList.remove('hidden');
    }
    else {
        bufferEl.classList.add('hidden');
    }
    // Live pause duration display
    var isLive = this.currentPlayingType === 'live' || (this.selectedStream && this.selectedStream.type === 'live');
    var progressRowEl = document.getElementById('player-progress-row');
    var durationEl = document.getElementById('player-duration');
    if (isLive) {
        // Always hide progress bar for live
        if (progressRowEl) progressRowEl.style.display = 'none';
        if (durationEl) durationEl.style.display = 'none';
        // Show pause duration if in timeshift
        if (this.player.isInTimeshift && liveBufferEl) {
            var bufferInfo = this.player.getBufferInfo();
            if (bufferInfo.available && bufferInfo.seconds > 0) {
                liveBufferEl.textContent = I18n.t('player.pauseDuration') + ': ' + this.player.formatTime(bufferInfo.seconds * 1000) + ' (' + I18n.t('player.returnToLive') + ')';
                liveBufferEl.classList.remove('hidden');
            }
            else {
                liveBufferEl.classList.add('hidden');
            }
        }
        else if (liveBufferEl) {
            liveBufferEl.classList.add('hidden');
        }
    }
    else if (liveBufferEl) {
        liveBufferEl.classList.add('hidden');
    }
    // Playback state indicator (in overlay)
    if (this.seekDirection !== 0 || this.seekDebounceTimer) {
        stateEl.textContent = this.wasPlaying ? '▶' : '❚❚';
    }
    else if (this.player.isPaused) {
        stateEl.textContent = '❚❚';
    }
    else {
        stateEl.textContent = '▶';
        this.bufferPercent = undefined;
    }
};

IPTVApp.prototype.showPlayerOverlay = function(extendedDelay) {
    var self = this;
    var hideDelay = extendedDelay ? 8000 : 5000;
    var overlay = document.getElementById('player-overlay');
    var titleEl = document.getElementById('player-title');
    var topRightEl = document.getElementById('player-top-right');
    var qualityEl = document.getElementById('player-quality');
    var progressRowEl = document.getElementById('player-progress-row');
    var durationEl = document.getElementById('player-duration');
    // Use currentPlayingType to check for live (catchup has progress bar)
    var isLive = this.currentPlayingType === 'live';
    overlay.classList.remove('hidden');
    if (topRightEl) topRightEl.classList.remove('hidden');
    titleEl.classList.remove('hidden');
    // Hide progress bar and time for live streams
    if (progressRowEl) progressRowEl.style.display = isLive ? 'none' : '';
    if (durationEl) durationEl.style.display = isLive ? 'none' : '';
    var streamData = this.currentPlayingStream || (this.selectedStream && this.selectedStream.data);
    if (streamData) {
        var title = streamData.name || streamData.title || '';
        var displayTitle = title;
        var year = this.extractYear(title);
        if (!year && this.tmdbInfo) {
            var dateStr = this.tmdbInfo.release_date || this.tmdbInfo.first_air_date;
            if (dateStr) {
                year = dateStr.substring(0, 4);
            }
        }
        displayTitle = this.cleanTitle(title);
        if (year) {
            displayTitle += ' (' + year + ')';
        }
        // Add season/episode info for series
        if (streamData.season && streamData.episode) {
            var s = streamData.season < 10 ? '0' + streamData.season : streamData.season;
            var e = streamData.episode < 10 ? '0' + streamData.episode : streamData.episode;
            displayTitle += ' - S' + s + 'E' + e;
        }
        document.getElementById('player-title-text').textContent = displayTitle;
        // Show duration next to title for non-live streams
        var durationEl = document.getElementById('player-duration');
        if (durationEl && !isLive && this.player.duration > 0) {
            durationEl.textContent = this.formatDuration(this.player.duration);
        }
        else if (durationEl) {
            durationEl.textContent = '';
        }
    }
    // Show quality on the right
    if (this.videoQuality && qualityEl) {
        qualityEl.textContent = this.videoQuality;
    }
    else if (qualityEl) {
        qualityEl.textContent = '';
    }
    this.updatePlayerStateIndicator();
    this.updatePlayerTracks();
    this.updatePlayerFavoriteIcon();
    if (this.overlayTimer) {
        clearTimeout(this.overlayTimer);
    }
    // Don't hide overlay while buffering or when track buttons are focused
    var isBuffering = this.isBuffering || (this.bufferPercent !== undefined && this.bufferPercent < 100);
    if (!isBuffering && !this.playerTracksFocused) {
        this.overlayTimer = setTimeout(function() {
            overlay.classList.add('hidden');
            titleEl.classList.add('hidden');
            if (topRightEl) topRightEl.classList.add('hidden');
        }, hideDelay);
    }
};

// Track selection
IPTVApp.prototype.updatePlayerTracks = function() {
    if (!this.player.isPlaying) return;
    var tracks = this.player.getTracks();
    var tracksDiv = document.getElementById('player-tracks');
    var audioBtn = document.getElementById('player-audio-btn');
    var subtitleBtn = document.getElementById('player-subtitle-btn');
    var optionsBtn = document.getElementById('player-sub-options-btn');
    var replayBtn = document.getElementById('player-replay-btn');
    var favoriteBtn = document.getElementById('player-favorite-btn');
    // Auto-select audio track matching interface language (only first time)
    if (!this._audioAutoSelected && tracks.audio.length > 1) {
        this.autoSelectAudioTrack(tracks.audio);
        this._audioAutoSelected = true;
    }
    this.availableTracks = tracks;
    var isCatchup = this.currentPlayingType === 'catchup';
    var visibleButtons = 0;
    if (tracks.audio.length > 1) {
        audioBtn.classList.remove('hidden');
        visibleButtons++;
        var audioLabel = tracks.audio[this.currentAudioIndex || 0];
        document.getElementById('player-audio-label').textContent = audioLabel ? audioLabel.language : 'Audio';
    }
    else {
        audioBtn.classList.add('hidden');
    }
    if (tracks.subtitle.length > 0) {
        subtitleBtn.classList.remove('hidden');
        visibleButtons++;
        var subIdx = this.currentSubtitleIndex;
        var subLabel = subIdx === -1 ? 'Désactivé' : (subIdx === -2 ? 'Externe' : (tracks.subtitle[subIdx] ? tracks.subtitle[subIdx].language : 'Sous-titres'));
        document.getElementById('player-subtitle-label').textContent = subLabel;
    }
    else {
        subtitleBtn.classList.add('hidden');
    }
    if (this.currentSubtitleIndex === -2) {
        optionsBtn.classList.remove('hidden');
        visibleButtons++;
    }
    else {
        optionsBtn.classList.add('hidden');
    }
    // Show replay button only for live streams with tv_archive enabled
    var stream = this.currentPlayingStream;
    var isLive = this.currentPlayingType === 'live';
    var hasReplay = stream && stream.tv_archive === 1;
    if (isLive && hasReplay && replayBtn) {
        replayBtn.classList.remove('hidden');
        visibleButtons++;
    }
    else if (replayBtn) {
        replayBtn.classList.add('hidden');
    }
    // Hide favorite button during catchup
    if (isCatchup && favoriteBtn) {
        favoriteBtn.classList.add('hidden');
    }
    else if (favoriteBtn) {
        favoriteBtn.classList.remove('hidden');
        visibleButtons++;
    }
    // Hide tracks div if no buttons visible
    if (visibleButtons === 0) {
        tracksDiv.classList.add('hidden');
    }
    else {
        tracksDiv.classList.remove('hidden');
    }
};

IPTVApp.prototype.reapplySubtitleTrack = function() {
    if (this.currentSubtitleIndex === undefined || this.currentSubtitleIndex === -1) {
        return;
    }
    var tracks = this.player.getTracks();
    if (this.currentSubtitleIndex === -2) {
        this.player.showSubtitles();
    }
    else if (this.currentSubtitleIndex >= 0 && tracks.subtitle[this.currentSubtitleIndex]) {
        var trackIndex = tracks.subtitle[this.currentSubtitleIndex].index;
        this.player.setSubtitleTrack(trackIndex);
        this.player.showSubtitles();
    }
};

// Auto-select audio track matching interface language
IPTVApp.prototype.autoSelectAudioTrack = function(audioTracks) {
    if (!audioTracks || audioTracks.length <= 1) return;
    var locale = this.settings.locale || 'en';
    var langCodes = I18n.getIso639Codes(locale);
    window.log('autoSelectAudioTrack: locale=' + locale + ' codes=' + langCodes.join(','));
    // Find track matching interface language
    for (var i = 0; i < audioTracks.length; i++) {
        var track = audioTracks[i];
        var trackLang = (track.lang || '').toLowerCase();
        for (var j = 0; j < langCodes.length; j++) {
            if (trackLang === langCodes[j].toLowerCase()) {
                window.log('autoSelectAudioTrack: found match at index ' + i + ' lang=' + trackLang);
                if (i !== (this.currentAudioIndex || 0)) {
                    this.currentAudioIndex = i;
                    this.player.setAudioTrack(track.index);
                }
                return;
            }
        }
    }
    window.log('autoSelectAudioTrack: no match found, keeping default');
};

IPTVApp.prototype.getSubtitleLangCodes = function(locale) {
    return I18n.getIso639Codes(locale);
};

IPTVApp.prototype.autoEnableForcedSubtitles = function() {
    // Only auto-enable if no subtitle was manually selected
    if (this.currentSubtitleIndex !== undefined && this.currentSubtitleIndex !== -1) {
        return;
    }
    var tracks = this.player.getTracks();
    if (!tracks.subtitle || tracks.subtitle.length === 0) {
        return;
    }
    var appLocale = (this.settings.locale || I18n.getLocale() || 'en').toLowerCase();
    var targetLangs = this.getSubtitleLangCodes(appLocale);
    // Find forced subtitle matching app language
    for (var i = 0; i < tracks.subtitle.length; i++) {
        var track = tracks.subtitle[i];
        if (!track.forced) {
            continue;
        }
        var trackLang = (track.lang || '').toLowerCase();
        for (var j = 0; j < targetLangs.length; j++) {
            if (trackLang.indexOf(targetLangs[j]) !== -1) {
                window.log('Auto-enabling forced subtitle: ' + track.lang + ' (index ' + i + ')');
                this.currentSubtitleIndex = i;
                this.player.setSubtitleTrack(track.index);
                this.player.showSubtitles();
                return;
            }
        }
    }
};

IPTVApp.prototype.focusPlayerTracks = function() {
    this.playerTracksFocused = true;
    this.playerTrackIndex = 0;
    this.updatePlayerTracksFocus();
};

IPTVApp.prototype.unfocusPlayerTracks = function(hideOverlay) {
    this.playerTracksFocused = false;
    document.querySelectorAll('.player-track-btn').forEach(function(el) {
        el.classList.remove('focused');
    });
    if (hideOverlay) {
        // Hide overlay immediately
        var overlay = document.getElementById('player-overlay');
        var titleEl = document.getElementById('player-title');
        var topRightEl = document.getElementById('player-top-right');
        if (overlay) overlay.classList.add('hidden');
        if (titleEl) titleEl.classList.add('hidden');
        if (topRightEl) topRightEl.classList.add('hidden');
    } else {
        // Restart overlay hide timer
        this.showPlayerOverlay();
    }
};

IPTVApp.prototype.updatePlayerTracksFocus = function() {
    var btns = document.querySelectorAll('#player-tracks .player-track-btn:not(.hidden)');
    btns.forEach(function(el) { el.classList.remove('focused'); });
    if (btns[this.playerTrackIndex]) {
        btns[this.playerTrackIndex].classList.add('focused');
    }
};

IPTVApp.prototype.cycleTrack = function(type) {
    var tracks = this.availableTracks;
    if (!tracks) return;
    if (type === 'audio' && tracks.audio.length > 1) {
        this.currentAudioIndex = ((this.currentAudioIndex || 0) + 1) % tracks.audio.length;
        this.player.setAudioTrack(tracks.audio[this.currentAudioIndex].index);
        document.getElementById('player-audio-label').textContent = tracks.audio[this.currentAudioIndex].language;
    }
    else if (type === 'subtitle') {
        var totalSubs = tracks.subtitle.length + 1;
        this.currentSubtitleIndex = ((this.currentSubtitleIndex === undefined ? 0 : this.currentSubtitleIndex + 1) + 1) % totalSubs - 1;
        if (this.currentSubtitleIndex === -1) {
            this.player.hideSubtitles();
            document.getElementById('player-subtitle-label').textContent = I18n.t('player.disabled');
        }
        else {
            this.player.setSubtitleTrack(tracks.subtitle[this.currentSubtitleIndex].index);
            this.player.showSubtitles();
            document.getElementById('player-subtitle-label').textContent = tracks.subtitle[this.currentSubtitleIndex].language;
        }
    }
};

IPTVApp.prototype.handlePlayerDown = function() {
    var tracksDiv = document.getElementById('player-tracks');
    if (!tracksDiv.classList.contains('hidden')) {
        // Only show overlay and focus tracks if there are buttons visible
        this.showPlayerOverlay();
        this.focusPlayerTracks();
    }
};

IPTVApp.prototype.navigatePlayerTracks = function(direction) {
    var btns = document.querySelectorAll('#player-tracks .player-track-btn:not(.hidden)');
    if (btns.length === 0) return;
    var newIndex = this.playerTrackIndex + direction;
    if (newIndex < 0) {
        this.startSeek(-1);
        return;
    }
    if (newIndex >= btns.length) {
        this.startSeek(1);
        return;
    }
    this.playerTrackIndex = newIndex;
    this.updatePlayerTracksFocus();
    this.showPlayerOverlay();
};

IPTVApp.prototype.selectPlayerTrack = function() {
    var btns = document.querySelectorAll('#player-tracks .player-track-btn:not(.hidden)');
    if (!btns[this.playerTrackIndex]) return;
    var btn = btns[this.playerTrackIndex];
    if (btn.id === 'player-audio-btn') {
        this.showTrackSelectionModal('audio');
    }
    else if (btn.id === 'player-subtitle-btn') {
        this.showTrackSelectionModal('subtitle');
    }
    else if (btn.id === 'player-sub-options-btn') {
        this.showSubtitleOptionsModal();
    }
    else if (btn.id === 'player-replay-btn') {
        this.openReplayFromPlayer();
    }
    else if (btn.id === 'player-favorite-btn') {
        this.togglePlayerFavorite();
    }
    else if (btn.id === 'player-speed-btn') {
        this.cyclePlaybackSpeed();
    }
    else if (btn.id === 'player-display-btn') {
        this.cycleDisplayMode();
    }
};

IPTVApp.prototype.openReplayFromPlayer = function() {
    window.log('ACTION openReplayFromPlayer');
    var stream = this.currentPlayingStream;
    if (!stream || this.currentPlayingType !== 'live') return;
    // Stop playback and open catchup modal
    this.player.stop();
    this.showScreen('browse');
    this.currentScreen = 'browse';
    this.showCatchupModal(stream);
};

IPTVApp.prototype.togglePlayerFavorite = function() {
    var stream = this.currentPlayingStream || (this.selectedStream && this.selectedStream.data);
    var type = this.currentPlayingType || (this.selectedStream && this.selectedStream.type) || 'vod';
    if (stream) {
        this.toggleFavorite(stream, type);
        this.updatePlayerFavoriteIcon();
    }
};

IPTVApp.prototype.updatePlayerFavoriteIcon = function() {
    var icon = document.getElementById('player-favorite-icon');
    if (!icon) return;
    var stream = this.currentPlayingStream || (this.selectedStream && this.selectedStream.data);
    if (stream) {
        var streamId = stream.stream_id || stream.series_id || stream.id;
        var isFav = this.isFavorite(streamId);
        icon.textContent = isFav ? '★' : '☆';
    }
};

// Playback speed cycling
// AVPlay: 1, 2, 4, 8 (negative for rewind not useful for normal use)
// HTML5: 0.5, 0.75, 1, 1.25, 1.5, 2
IPTVApp.prototype.cyclePlaybackSpeed = function() {
    var speeds = this.player.useHtml5 ? [0.5, 0.75, 1, 1.25, 1.5, 2] : [1, 2, 4, 8];
    var current = this.player.getSpeed();
    var idx = speeds.indexOf(current);
    var next = speeds[(idx + 1) % speeds.length];
    window.log('ACTION cyclePlaybackSpeed: ' + current + ' -> ' + next);
    this.player.setSpeed(next);
    this.updateSpeedLabel();
};

IPTVApp.prototype.updateSpeedLabel = function() {
    var label = document.getElementById('player-speed-label');
    if (label) {
        var speed = this.player.getSpeed();
        label.textContent = '×' + speed;
    }
};

// Display mode cycling: auto -> letterbox -> stretch -> zoom
IPTVApp.prototype.cycleDisplayMode = function() {
    var modes = ['auto', 'letterbox', 'stretch', 'zoom'];
    var current = this.player.getDisplayMode();
    var idx = modes.indexOf(current);
    var next = modes[(idx + 1) % modes.length];
    window.log('ACTION cycleDisplayMode: ' + current + ' -> ' + next);
    this.player.setDisplayMode(next);
    this.updateDisplayLabel();
};

IPTVApp.prototype.updateDisplayLabel = function() {
    var label = document.getElementById('player-display-label');
    if (label) {
        var mode = this.player.getDisplayMode();
        var labels = {
            'auto': I18n.t('player.displayAuto'),
            'letterbox': I18n.t('player.displayLetterbox'),
            'stretch': I18n.t('player.displayStretch'),
            'zoom': I18n.t('player.displayZoom')
        };
        label.textContent = labels[mode] || mode;
    }
};

IPTVApp.prototype.showTrackSelectionModal = function(type) {
    window.log('TRACK showModal type=' + type);
    var self = this;
    var tracks = this.availableTracks;
    if (!tracks) return;
    var audioList = document.getElementById('audio-tracks-list');
    var subtitleList = document.getElementById('subtitle-tracks-list');
    var audioSection = audioList.parentElement;
    var subtitleSection = subtitleList.parentElement;
    audioList.innerHTML = '';
    subtitleList.innerHTML = '';
    this.trackModalItems = [];
    if (type === 'audio') {
        audioSection.classList.remove('hidden');
        subtitleSection.classList.add('hidden');
        for (var i = 0; i < tracks.audio.length; i++) {
            var item = document.createElement('div');
            item.className = 'track-item focusable';
            item.dataset.type = 'audio';
            item.dataset.index = tracks.audio[i].index;
            item.dataset.idx = i;
            item.textContent = tracks.audio[i].language;
            if (i === (this.currentAudioIndex || 0)) item.classList.add('selected');
            audioList.appendChild(item);
            this.trackModalItems.push(item);
        }
    }
    else {
        audioSection.classList.add('hidden');
        subtitleSection.classList.remove('hidden');
        var noSubItem = document.createElement('div');
        noSubItem.className = 'track-item focusable';
        noSubItem.dataset.type = 'subtitle';
        noSubItem.dataset.index = '-1';
        noSubItem.textContent = I18n.t('player.disabled');
        if (this.currentSubtitleIndex === -1 || this.currentSubtitleIndex === undefined) noSubItem.classList.add('selected');
        subtitleList.appendChild(noSubItem);
        this.trackModalItems.push(noSubItem);
        for (var j = 0; j < tracks.subtitle.length; j++) {
            var subItem = document.createElement('div');
            subItem.className = 'track-item focusable';
            subItem.dataset.type = 'subtitle';
            subItem.dataset.index = tracks.subtitle[j].index;
            subItem.dataset.idx = j;
            subItem.textContent = tracks.subtitle[j].language;
            if (j === this.currentSubtitleIndex) subItem.classList.add('selected');
            subtitleList.appendChild(subItem);
            this.trackModalItems.push(subItem);
        }
        if (typeof SubDL !== 'undefined' && SubDL.isEnabled()) {
            var sdItem = document.createElement('div');
            sdItem.className = 'track-item focusable';
            sdItem.dataset.type = 'subdl';
            sdItem.textContent = '🔍 ' + I18n.t('subtitleSearch.searchSubDL');
            subtitleList.appendChild(sdItem);
            this.trackModalItems.push(sdItem);
        }
        if (typeof OpenSubtitles !== 'undefined' && OpenSubtitles.isEnabled()) {
            var osItem = document.createElement('div');
            osItem.className = 'track-item focusable opensubtitles-item';
            osItem.dataset.type = 'opensubtitles';
            osItem.textContent = '🔍 ' + I18n.t('subtitleSearch.searchOpenSubtitles');
            subtitleList.appendChild(osItem);
            this.trackModalItems.push(osItem);
        }
    }
    document.getElementById('tracks-modal').classList.remove('hidden');
    this.focusArea = 'tracks';
    this.focusIndex = 0;
    for (var k = 0; k < this.trackModalItems.length; k++) {
        if (this.trackModalItems[k].classList.contains('selected')) {
            this.focusIndex = k;
            break;
        }
    }
    this.updateFocus();
};

IPTVApp.prototype.confirmTrackSelection = function() {
    if (!this.trackModalItems || this.focusIndex >= this.trackModalItems.length) return;
    var item = this.trackModalItems[this.focusIndex];
    var type = item.dataset.type;
    var index = parseInt(item.dataset.index);
    var idx = parseInt(item.dataset.idx);
    window.log('TRACK select type=' + type + ' index=' + index + ' idx=' + idx + ' text=' + item.textContent);
    if (type === 'audio') {
        this.currentAudioIndex = idx;
        this.player.setAudioTrack(index);
        document.getElementById('player-audio-label').textContent = item.textContent;
    }
    else if (type === 'subtitle') {
        if (index === -1) {
            this.currentSubtitleIndex = -1;
            this.externalSubtitles = null;
            this.lastExternalSubtitle = null;
            this.player.hideSubtitles();
            document.getElementById('player-subtitle-label').textContent = I18n.t('player.disabled');
        }
        else {
            this.currentSubtitleIndex = idx;
            this.player.setSubtitleTrack(index);
            this.player.showSubtitles();
            document.getElementById('player-subtitle-label').textContent = item.textContent;
        }
    }
    else if (type === 'subdl') {
        this.searchSubDL();
        return;
    }
    else if (type === 'opensubtitles') {
        this.searchOpenSubtitles();
        return;
    }
    else if (type === 'sd-back' || type === 'os-back') {
        this.showTrackSelectionModal('subtitle');
        return;
    }
    else if (type === 'os-result') {
        this.downloadOpenSubtitle(idx);
        return;
    }
    else if (type === 'sd-result') {
        this.downloadSubDLSubtitle(idx);
        return;
    }
    this.hideTracksModal();
    this.showPlayerOverlay(true);
};

// Subtitle search
IPTVApp.prototype.searchOpenSubtitles = function() {
    var self = this;
    window.log('searchOpenSubtitles tmdbInfo=' + (this.tmdbInfo ? 'yes' : 'no') + ' enabled=' + OpenSubtitles.isEnabled());
    if (!this.tmdbInfo || !OpenSubtitles.isEnabled()) {
        window.log('searchOpenSubtitles aborted');
        return;
    }
    this.showLoading(true);
    var params = {
        languages: 'fr,en'
    };
    if (this.tmdbInfo.external_ids && this.tmdbInfo.external_ids.imdb_id) {
        params.imdb_id = this.tmdbInfo.external_ids.imdb_id;
    }
    else if (this.tmdbInfo.id) {
        params.tmdb_id = this.tmdbInfo.id;
    }
    if (this.selectedEpisode) {
        params.type = 'episode';
        params.season_number = this.selectedEpisode.season;
        params.episode_number = this.selectedEpisode.episode;
        if (this.tmdbInfo.id) {
            params.parent_tmdb_id = this.tmdbInfo.id;
        }
    }
    else if (this.tmdbInfo._type === 'tv') {
        params.type = 'tvshow';
    }
    else {
        params.type = 'movie';
    }
    window.log('OpenSubtitles.search params=' + JSON.stringify(params));
    OpenSubtitles.search(params, function(err, results) {
        window.log('OpenSubtitles.search result err=' + err + ' count=' + (results ? results.length : 0));
        if (err) {
            self.showLoading(false);
            return;
        }
        if (!results || results.length === 0) {
            self.showLoading(false);
            return;
        }
        self.showOpenSubtitlesResults(results);
    });
};

IPTVApp.prototype.searchSubDL = function() {
    var self = this;
    window.log('searchSubDL tmdbInfo=' + (this.tmdbInfo ? 'yes' : 'no') + ' enabled=' + SubDL.isEnabled());
    if (!this.tmdbInfo || !SubDL.isEnabled()) {
        window.log('searchSubDL aborted');
        return;
    }
    this.showLoading(true);
    var params = {
        languages: 'fr,en'
    };
    if (this.tmdbInfo.external_ids && this.tmdbInfo.external_ids.imdb_id) {
        params.imdb_id = this.tmdbInfo.external_ids.imdb_id;
    }
    else if (this.tmdbInfo.id) {
        params.tmdb_id = this.tmdbInfo.id;
    }
    params.type = this.tmdbInfo._type || 'movie';
    if (this.selectedEpisode) {
        params.season_number = this.selectedEpisode.season;
        params.episode_number = this.selectedEpisode.episode;
    }
    window.log('SubDL.search params=' + JSON.stringify(params));
    SubDL.search(params, function(err, results) {
        window.log('SubDL.search result err=' + err + ' count=' + (results ? results.length : 0));
        if (err) {
            self.showLoading(false);
            return;
        }
        if (!results || results.length === 0) {
            self.showLoading(false);
            return;
        }
        self.showSubDLResults(results);
    });
};

IPTVApp.prototype.showSubDLResults = function(results) {
    var self = this;
    this.showLoading(false);
    var subtitleList = document.getElementById('subtitle-tracks-list');
    subtitleList.innerHTML = '';
    this.trackModalItems = [];
    this.subDLResults = results;
    var backItem = document.createElement('div');
    backItem.className = 'track-item focusable';
    backItem.dataset.type = 'sd-back';
    backItem.textContent = '← ' + I18n.t('subtitleSearch.back');
    subtitleList.appendChild(backItem);
    this.trackModalItems.push(backItem);
    for (var i = 0; i < Math.min(results.length, 15); i++) {
        var sub = results[i];
        var item = document.createElement('div');
        item.className = 'track-item focusable';
        item.dataset.type = 'sd-result';
        item.dataset.idx = i;
        var label = (sub.language || 'Unknown').toUpperCase();
        if (sub.release) label += ' - ' + sub.release.substring(0, 40);
        if (sub.hearing_impaired) label += ' [SDH]';
        item.textContent = label;
        subtitleList.appendChild(item);
        this.trackModalItems.push(item);
    }
    this.focusIndex = 0;
    this.updateFocus();
};

IPTVApp.prototype.downloadSubDLSubtitle = function(idx) {
    var self = this;
    var sub = this.subDLResults ? this.subDLResults[idx] : null;
    window.log('SUBTITLE SubDL download idx=' + idx + ' sub=' + (sub ? 'found' : 'null'));
    if (!sub) return;
    window.log('SUBTITLE SubDL url=' + sub.download_url);
    this.showLoading(true);
    SubDL.downloadZip(sub.download_url, function(err, zipResult) {
        if (err) {
            window.log('ERROR SUBTITLE SubDL download: ' + (err.error || err));
            self.showLoading(false);
            return;
        }
        window.log('SUBTITLE SubDL zip ok, extracting...');
        SubDL.extractSrtFromZip(zipResult.data, function(err, srtContent) {
            if (err) {
                window.log('ERROR SUBTITLE SubDL extract: ' + (err.error || err));
                self.showLoading(false);
                return;
            }
            window.log('SUBTITLE SubDL SRT length=' + srtContent.length);
            self.externalSubtitleContent = srtContent;
            self.parseAndLoadSubtitle(srtContent);
            self.currentSubtitleIndex = -2;
            // Disable embedded subtitles when using external
            self.player.hideSubtitles();
            self.showLoading(false);
            self.hideTracksModal();
            self.showPlayerOverlay(true);
            document.getElementById('player-subtitle-label').textContent = (sub.language || 'SUB').toUpperCase();
        });
    });
};

IPTVApp.prototype.showOpenSubtitlesResults = function(results) {
    var self = this;
    this.showLoading(false);
    var subtitleList = document.getElementById('subtitle-tracks-list');
    subtitleList.innerHTML = '';
    this.trackModalItems = [];
    this.openSubtitlesResults = results;
    var backItem = document.createElement('div');
    backItem.className = 'track-item focusable';
    backItem.dataset.type = 'os-back';
    backItem.textContent = '← ' + I18n.t('subtitleSearch.back');
    subtitleList.appendChild(backItem);
    this.trackModalItems.push(backItem);
    for (var i = 0; i < Math.min(results.length, 10); i++) {
        var sub = results[i];
        var item = document.createElement('div');
        item.className = 'track-item focusable';
        item.dataset.type = 'os-result';
        item.dataset.idx = i;
        var label = sub.language.toUpperCase();
        if (sub.release) label += ' - ' + sub.release;
        if (sub.hearing_impaired) label += ' [SDH]';
        if (sub.ai_translated) label += ' [AI]';
        item.textContent = label;
        subtitleList.appendChild(item);
        this.trackModalItems.push(item);
    }
    this.focusIndex = 0;
    this.updateFocus();
};

IPTVApp.prototype.downloadOpenSubtitle = function(idx) {
    var self = this;
    var sub = this.openSubtitlesResults[idx];
    if (!sub) return;
    window.log('OpenSubtitles download idx=' + idx + ' file_id=' + sub.file_id);
    this.showLoading(true);
    OpenSubtitles.getDownloadLink(sub.file_id, function(err, download) {
        if (err) {
            window.log('ERROR OpenSubtitles getDownloadLink: ' + (err.error || err));
            self.showLoading(false);
            return;
        }
        window.log('OpenSubtitles downloading from: ' + download.link);
        OpenSubtitles.downloadContent(download.link, function(err, content) {
            if (err) {
                window.log('ERROR OpenSubtitles download: ' + (err.error || err));
                self.showLoading(false);
                return;
            }
            window.log('OpenSubtitles content downloaded, length=' + content.length);
            self.externalSubtitleContent = content;
            self.parseAndLoadSubtitle(content);
            self.currentSubtitleIndex = -2;
            // Disable embedded subtitles when using external
            self.player.hideSubtitles();
            self.showLoading(false);
            self.hideTracksModal();
            self.showPlayerOverlay(true);
            document.getElementById('player-subtitle-label').textContent = sub.language.toUpperCase();
        });
    });
};

IPTVApp.prototype.parseAndLoadSubtitle = function(srtContent) {
    var self = this;
    this.externalSubtitles = [];
    // Normalize line endings (handle Windows \r\n and Mac \r)
    var normalized = srtContent.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    var blocks = normalized.trim().split(/\n\n+/);
    window.log('SUBTITLE parsing blocks=' + blocks.length);
    for (var i = 0; i < blocks.length; i++) {
        var lines = blocks[i].split('\n');
        if (lines.length >= 3) {
            var timeLine = lines[1] || lines[0];
            var timeMatch = timeLine.match(Regex.srtTiming);
            if (timeMatch) {
                var startMs = parseInt(timeMatch[1]) * 3600000 + parseInt(timeMatch[2]) * 60000 + parseInt(timeMatch[3]) * 1000 + parseInt(timeMatch[4]);
                var endMs = parseInt(timeMatch[5]) * 3600000 + parseInt(timeMatch[6]) * 60000 + parseInt(timeMatch[7]) * 1000 + parseInt(timeMatch[8]);
                var textLines = lines.slice(2);
                if (lines[0].match(Regex.srtIndex)) textLines = lines.slice(2);
                else textLines = lines.slice(1);
                textLines = textLines.filter(function(l) { return l.trim() && !l.match(Regex.srtArrow); });
                var text = textLines.join('<br>');
                var parsed = self.parseAssaTags(text);
                if (parsed.text.trim()) {
                    self.externalSubtitles.push({
                        start: startMs,
                        end: endMs,
                        text: parsed.text,
                        align: parsed.align,
                        pos: parsed.pos
                    });
                }
            }
        }
    }
    this.player.subtitlesEnabled = true;
    this.currentSubtitleIndex = -2;
    this.subtitleOffset = 0;
    window.log('SUBTITLE parsed count=' + this.externalSubtitles.length);
    if (this.externalSubtitles.length > 0) {
        var first = this.externalSubtitles[0];
        window.log('SUBTITLE first: start=' + first.start + 'ms end=' + first.end + 'ms text=' + first.text.substring(0, 30));
    }
};

// Parse ASS/SSA tags and convert to HTML
IPTVApp.prototype.parseAssaTags = function(text) {
    var align = null;
    var pos = null;
    // Extract alignment {\an1-9}
    var anMatch = text.match(/\{\\an(\d)\}/);
    if (anMatch) {
        align = parseInt(anMatch[1]);
    }
    // Extract position {\pos(x,y)}
    var posMatch = text.match(/\{\\pos\((\d+),(\d+)\)\}/);
    if (posMatch) {
        pos = { x: parseInt(posMatch[1]), y: parseInt(posMatch[2]) };
    }
    // Convert formatting tags to HTML
    text = text
        // Bold
        .replace(/\{\\b1\}/g, '<b>').replace(/\{\\b0\}/g, '</b>')
        // Italic
        .replace(/\{\\i1\}/g, '<i>').replace(/\{\\i0\}/g, '</i>')
        // Underline
        .replace(/\{\\u1\}/g, '<u>').replace(/\{\\u0\}/g, '</u>')
        // Color {\c&HBBGGRR&} or {\1c&HBBGGRR&}
        .replace(/\{\\1?c&H([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})&\}/g, function(m, b, g, r) {
            return '<span style="color:#' + r + g + b + '">';
        })
        // Font size {\fsNN}
        .replace(/\{\\fs(\d+)\}/g, '<span style="font-size:$1px">')
        // Remove remaining ASS tags
        .replace(/\{\\[^}]*\}/g, '');
    // Clean up multiple <br> in a row
    text = text.replace(/(<br>\s*)+/g, '<br>').replace(/^<br>|<br>$/g, '');
    return { text: text, align: align, pos: pos };
};

// Subtitle options
IPTVApp.prototype.adjustSubtitleOffset = function(deltaMs) {
    this.subtitleOffset = (this.subtitleOffset || 0) + deltaMs;
    this.updateSubtitleOffsetDisplay();
    // Apply native subtitle sync for embedded subtitles (not external SRT)
    if (this.currentSubtitleIndex >= 0 && this.player) {
        this.player.setSubtitleSync(this.subtitleOffset);
    }
};

IPTVApp.prototype.updateSubtitleOffsetDisplay = function() {
    var display = document.getElementById('sub-offset-display');
    if (display) {
        var sign = this.subtitleOffset >= 0 ? '+' : '';
        display.textContent = sign + (this.subtitleOffset / 1000).toFixed(1) + 's';
    }
};

IPTVApp.prototype.showSubtitleOptionsModal = function() {
    window.log('ACTION showSubtitleOptionsModal');
    this.subtitleSize = this.subtitleSize || 'medium';
    this.subtitleStyle = this.subtitleStyle || 'shadow';
    this.subtitleOffset = this.subtitleOffset || 0;
    this.updateSubtitleOffsetDisplay();
    var modal = document.getElementById('sub-options-modal');
    modal.querySelectorAll('.sub-option-btn[data-action="size"]').forEach(function(btn) {
        btn.classList.toggle('selected', btn.dataset.value === this.subtitleSize);
    }.bind(this));
    modal.querySelectorAll('.sub-option-btn[data-action="style"]').forEach(function(btn) {
        btn.classList.toggle('selected', btn.dataset.value === this.subtitleStyle);
    }.bind(this));
    modal.classList.remove('hidden');
    this.focusArea = 'sub-options';
    this.subOptionsItems = Array.from(modal.querySelectorAll('.sub-option-btn.focusable'));
    this.focusIndex = this.subOptionsItems.length - 1;
    this.updateFocus();
};

IPTVApp.prototype.hideSubtitleOptionsModal = function() {
    document.getElementById('sub-options-modal').classList.add('hidden');
    this.focusArea = '';
    this.unfocusPlayerTracks();
    this.showPlayerOverlay(true);
};

IPTVApp.prototype.handleSubtitleOption = function() {
    if (!this.subOptionsItems || this.focusIndex >= this.subOptionsItems.length) return;
    var btn = this.subOptionsItems[this.focusIndex];
    var action = btn.dataset.action;
    var value = btn.dataset.value;
    window.log('ACTION subtitleOption: ' + action + '=' + value);
    if (action === 'offset') {
        this.adjustSubtitleOffset(parseInt(value));
    }
    else if (action === 'size') {
        this.subtitleSize = value;
        this.applySubtitleStyle();
        document.querySelectorAll('.sub-option-btn[data-action="size"]').forEach(function(b) {
            b.classList.toggle('selected', b.dataset.value === value);
        });
    }
    else if (action === 'style') {
        this.subtitleStyle = value;
        this.applySubtitleStyle();
        document.querySelectorAll('.sub-option-btn[data-action="style"]').forEach(function(b) {
            b.classList.toggle('selected', b.dataset.value === value);
        });
    }
    else if (action === 'close') {
        this.hideSubtitleOptionsModal();
    }
};

IPTVApp.prototype.applySubtitleStyle = function() {
    var el = document.getElementById('subtitle-display');
    if (!el) return;
    el.classList.remove('size-small', 'size-medium', 'size-large');
    el.classList.remove('style-shadow', 'style-background', 'style-none');
    el.classList.add('size-' + (this.subtitleSize || 'medium'));
    el.classList.add('style-' + (this.subtitleStyle || 'shadow'));
};

IPTVApp.prototype.displayExternalSubtitle = function(currentTimeMs) {
    var subtitleEl = document.getElementById('subtitle-display');
    if (!subtitleEl) return;
    if (this.currentSubtitleIndex !== -2 || !this.externalSubtitles || this.externalSubtitles.length === 0) {
        if (!this._subtitleDebugLogged) {
            window.log('SUBTITLE skip: idx=' + this.currentSubtitleIndex + ' subs=' + (this.externalSubtitles ? this.externalSubtitles.length : 'null'));
            this._subtitleDebugLogged = true;
        }
        return;
    }
    this._subtitleDebugLogged = false;
    var offset = this.subtitleOffset || 0;
    var adjustedTime = currentTimeMs - offset;
    var found = null;
    for (var i = 0; i < this.externalSubtitles.length; i++) {
        var sub = this.externalSubtitles[i];
        if (adjustedTime >= sub.start && adjustedTime <= sub.end) {
            found = sub;
            break;
        }
    }
    if (found) {
        if (this.lastExternalSubtitle !== found.text) {
            if (!this._subtitleShownLogged) {
                window.log('SUBTITLE showing: time=' + adjustedTime + 'ms text=' + found.text.substring(0, 30));
                this._subtitleShownLogged = true;
            }
            this.applySubtitlePosition(subtitleEl, found.align, found.pos);
            window.displaySubtitle(subtitleEl, found.text);
            this.lastExternalSubtitle = found.text;
        }
    }
    else {
        if (this.lastExternalSubtitle) {
            window.displaySubtitle(subtitleEl, '');
            this.lastExternalSubtitle = null;
            this.resetSubtitlePosition(subtitleEl);
        }
    }
};

// Apply ASS/SSA alignment and position to subtitle element
IPTVApp.prototype.applySubtitlePosition = function(el, align, pos) {
    // Reset to default first
    el.style.top = '';
    el.style.bottom = '100px';
    el.style.left = '50%';
    el.style.right = '';
    el.style.transform = 'translateX(-50%)';
    el.style.textAlign = 'center';
    if (pos) {
        // Absolute positioning
        el.style.left = pos.x + 'px';
        el.style.top = pos.y + 'px';
        el.style.bottom = '';
        el.style.transform = '';
    }
    else if (align) {
        // Numpad-style alignment (1-9)
        // Vertical: 1-3 = bottom, 4-6 = middle, 7-9 = top
        // Horizontal: 1,4,7 = left, 2,5,8 = center, 3,6,9 = right
        var row = Math.ceil(align / 3); // 1=bottom, 2=middle, 3=top
        var col = ((align - 1) % 3) + 1; // 1=left, 2=center, 3=right
        // Vertical
        if (row === 3) {
            el.style.top = '50px';
            el.style.bottom = '';
        }
        else if (row === 2) {
            el.style.top = '50%';
            el.style.bottom = '';
            el.style.transform = col === 2 ? 'translate(-50%, -50%)' : 'translateY(-50%)';
        }
        // row === 1 uses default bottom
        // Horizontal
        if (col === 1) {
            el.style.left = '50px';
            el.style.transform = row === 2 ? 'translateY(-50%)' : '';
            el.style.textAlign = 'left';
        }
        else if (col === 3) {
            el.style.left = '';
            el.style.right = '50px';
            el.style.transform = row === 2 ? 'translateY(-50%)' : '';
            el.style.textAlign = 'right';
        }
    }
};

// Reset subtitle position to default
IPTVApp.prototype.resetSubtitlePosition = function(el) {
    el.style.top = '';
    el.style.bottom = '100px';
    el.style.left = '50%';
    el.style.right = '';
    el.style.transform = 'translateX(-50%)';
    el.style.textAlign = 'center';
};

// Catchup/Replay Modal
IPTVApp.prototype.showCatchupModal = function(stream) {
    var self = this;
    this.catchupStream = stream;
    this.catchupSelectedDay = 0;
    this.catchupFocusArea = 'days';
    this.catchupFocusIndex = 0;
    this.catchupPrograms = [];
    var archiveDuration = parseInt(stream.tv_archive_duration, 10) || 5;
    var modal = document.getElementById('catchup-modal');
    var channelName = document.getElementById('catchup-channel-name');
    var daysSelector = document.getElementById('catchup-days-selector');
    var loading = document.getElementById('catchup-loading');
    var programsList = document.getElementById('catchup-programs-list');
    channelName.textContent = '⏪ ' + this.stripCategoryPrefix(stream.name || stream.title || '');
    daysSelector.innerHTML = '';
    var locale = this.settings.locale || I18n.getLocale() || 'en';
    var dayLabels = [I18n.t('catchup.today') || "Aujourd'hui", I18n.t('catchup.yesterday') || 'Hier'];
    for (var i = 2; i < archiveDuration; i++) {
        var d = new Date();
        d.setDate(d.getDate() - i);
        dayLabels.push(d.toLocaleDateString(locale, { weekday: 'short', day: 'numeric' }));
    }
    for (var i = 0; i < Math.min(archiveDuration, dayLabels.length); i++) {
        var btn = document.createElement('div');
        btn.className = 'catchup-day-btn focusable' + (i === 0 ? ' selected' : '');
        btn.dataset.day = i;
        btn.textContent = dayLabels[i];
        daysSelector.appendChild(btn);
    }
    programsList.innerHTML = '';
    loading.classList.remove('hidden');
    modal.classList.remove('hidden');
    this.currentScreen = 'catchup-modal';
    this.focusArea = 'catchup-modal';
    this.loadCatchupPrograms(stream.stream_id, 0);
};

IPTVApp.prototype.loadCatchupPrograms = function(streamId, daysAgo) {
    var self = this;
    var loading = document.getElementById('catchup-loading');
    var programsList = document.getElementById('catchup-programs-list');
    loading.classList.remove('hidden');
    programsList.innerHTML = '';
    if (!this.api || !this.api.getEPG) {
        loading.textContent = I18n.t('errors.noData') || 'No EPG data';
        return;
    }
    var locale = this.settings.locale || I18n.getLocale() || 'en';
    this.api.getEPG(streamId).then(function(data) {
        loading.classList.add('hidden');
        if (!data || !data.epg_listings || data.epg_listings.length === 0) {
            programsList.innerHTML = '<div style="color:#888;padding:20px;">' + (I18n.t('errors.noData') || 'No programs') + '</div>';
            return;
        }
        var now = Math.floor(Date.now() / 1000);
        var targetDate = new Date();
        targetDate.setDate(targetDate.getDate() - daysAgo);
        var targetDayStart = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate()).getTime() / 1000;
        var targetDayEnd = targetDayStart + 86400;
        var filteredPrograms = data.epg_listings.filter(function(prog) {
            var start = parseInt(prog.start_timestamp, 10);
            var end = parseInt(prog.stop_timestamp, 10);
            // Only show programs from target day that are finished (not future)
            return start >= targetDayStart && start < targetDayEnd && end <= now;
        });
        filteredPrograms.sort(function(a, b) {
            return parseInt(a.start_timestamp, 10) - parseInt(b.start_timestamp, 10);
        });
        self.catchupPrograms = filteredPrograms;
        if (filteredPrograms.length === 0) {
            programsList.innerHTML = '<div style="color:#888;padding:20px;">' + (I18n.t('errors.noData') || 'No programs') + '</div>';
            return;
        }
        filteredPrograms.forEach(function(prog, idx) {
            var start = parseInt(prog.start_timestamp, 10);
            var end = parseInt(prog.stop_timestamp, 10);
            var duration = Math.round((end - start) / 60);
            var isLive = now >= start && now < end;
            var isPast = now >= end;
            var startTime = new Date(start * 1000);
            var timeStr = startTime.toLocaleTimeString(locale, { hour: '2-digit', minute: '2-digit' });
            var title = prog.title;
            try {
                title = decodeURIComponent(escape(atob(prog.title)));
            }
            catch (e) {}
            var item = document.createElement('div');
            item.className = 'catchup-program focusable' + (isLive ? ' live' : '') + (idx === 0 ? ' focused' : '');
            item.dataset.index = idx;
            item.dataset.start = start;
            item.dataset.end = end;
            item.dataset.isPast = isPast ? '1' : '0';
            item.innerHTML = '<div class="catchup-program-time">' + timeStr + '</div>' +
                '<div class="catchup-program-title">' + title + (isLive ? ' <span style="color:#e50914;">●</span>' : '') + '</div>' +
                '<div class="catchup-program-duration">' + duration + ' min</div>';
            programsList.appendChild(item);
        });
        self.catchupFocusArea = 'programs';
        self.catchupFocusIndex = 0;
        self.updateCatchupFocus();
    }).catch(function(e) {
        loading.classList.add('hidden');
        programsList.innerHTML = '<div style="color:#ff6b6b;padding:20px;">Error: ' + e + '</div>';
    });
};

IPTVApp.prototype.hideCatchupModal = function() {
    document.getElementById('catchup-modal').classList.add('hidden');
    var stream = this.catchupStream;
    var returnToLive = this.returnToLiveAfterCatchup;
    this.catchupStream = null;
    this.catchupPrograms = [];
    this.returnToLiveAfterCatchup = false;
    // Return to live playback if we came from catchup
    if (returnToLive && stream) {
        this.playStream(stream.stream_id, 'live', stream);
        return;
    }
    this.currentScreen = 'browse';
    this.focusArea = 'grid';
    this.updateFocus();
};

IPTVApp.prototype.updateCatchupFocus = function() {
    var days = document.querySelectorAll('#catchup-days-selector .catchup-day-btn');
    var programs = document.querySelectorAll('#catchup-programs-list .catchup-program');
    days.forEach(function(d, i) {
        d.classList.toggle('focused', this.catchupFocusArea === 'days' && i === this.catchupFocusIndex);
    }, this);
    programs.forEach(function(p, i) {
        p.classList.toggle('focused', this.catchupFocusArea === 'programs' && i === this.catchupFocusIndex);
    }, this);
    if (this.catchupFocusArea === 'programs' && programs[this.catchupFocusIndex]) {
        programs[this.catchupFocusIndex].scrollIntoView({ block: 'nearest' });
    }
};

IPTVApp.prototype.navigateCatchupModal = function(direction) {
    var days = document.querySelectorAll('#catchup-days-selector .catchup-day-btn');
    var programs = document.querySelectorAll('#catchup-programs-list .catchup-program');
    if (this.catchupFocusArea === 'days') {
        if (direction === 'left' && this.catchupFocusIndex > 0) {
            this.catchupFocusIndex--;
        }
        else if (direction === 'right' && this.catchupFocusIndex < days.length - 1) {
            this.catchupFocusIndex++;
        }
        else if (direction === 'down' && programs.length > 0) {
            this.catchupFocusArea = 'programs';
            this.catchupFocusIndex = 0;
        }
    }
    else if (this.catchupFocusArea === 'programs') {
        if (direction === 'up') {
            if (this.catchupFocusIndex > 0) {
                this.catchupFocusIndex--;
            }
            else {
                this.catchupFocusArea = 'days';
                this.catchupFocusIndex = this.catchupSelectedDay;
            }
        }
        else if (direction === 'down' && this.catchupFocusIndex < programs.length - 1) {
            this.catchupFocusIndex++;
        }
    }
    this.updateCatchupFocus();
};

IPTVApp.prototype.selectCatchupItem = function() {
    if (this.catchupFocusArea === 'days') {
        var days = document.querySelectorAll('#catchup-days-selector .catchup-day-btn');
        days.forEach(function(d) { d.classList.remove('selected'); });
        if (days[this.catchupFocusIndex]) {
            days[this.catchupFocusIndex].classList.add('selected');
            this.catchupSelectedDay = this.catchupFocusIndex;
            this.loadCatchupPrograms(this.catchupStream.stream_id, this.catchupFocusIndex);
        }
    }
    else if (this.catchupFocusArea === 'programs') {
        var prog = this.catchupPrograms[this.catchupFocusIndex];
        if (!prog) {
            window.log('selectCatchupItem: no program at index ' + this.catchupFocusIndex);
            return;
        }
        var start = parseInt(prog.start_timestamp, 10);
        var end = parseInt(prog.stop_timestamp, 10);
        var duration = Math.round((end - start) / 60);
        window.log('selectCatchupItem: program start=' + start + ' end=' + end + ' duration=' + duration + 'min');
        // Save stream and programs before hiding modal (hideCatchupModal clears them)
        var stream = this.catchupStream;
        var programs = this.catchupPrograms.slice();
        var programIndex = this.catchupFocusIndex;
        if (!stream) {
            window.log('selectCatchupItem: no stream!');
            return;
        }
        window.log('selectCatchupItem: stream=' + stream.stream_id + ' ' + stream.name);
        // Just hide the modal visually, don't reset focus (playCatchup will set it)
        document.getElementById('catchup-modal').classList.add('hidden');
        this.catchupStream = null;
        this.catchupPrograms = [];
        this.playCatchup(stream, start, duration, 'm3u8', null, null, programs, programIndex);
    }
};

IPTVApp.prototype.playCatchup = function(stream, startTimestamp, durationMinutes, extension, formatIndex, triedFormats, programs, programIndex) {
    extension = extension || 'ts';
    triedFormats = triedFormats || [];
    // Reset debug flag for progress logging
    this._catchupLogDone = false;
    // Use saved format if available and no format specified
    if (formatIndex === undefined || formatIndex === null) {
        formatIndex = this.settings.catchupFormat || 0;
    }
    triedFormats.push(formatIndex);
    var streamId = stream.stream_id;
    // Request 1 minute earlier to allow sync seek
    var adjustedStart = startTimestamp - 60;
    var adjustedDuration = durationMinutes + 1;
    var url = this.api.getCatchupUrl(streamId, adjustedStart, adjustedDuration, extension, formatIndex);
    window.log('Playing catchup format ' + formatIndex + ': ' + url);
    this.showScreen('player');
    this.currentScreen = 'player';
    this.focusArea = 'player';
    this.playerTracksFocused = false;
    this.currentPlayingStream = stream;
    this.currentPlayingType = 'catchup';
    // Store programs list and current index for next/prev navigation
    if (programs) {
        this.catchupPlaylist = programs;
        this.catchupPlaylistIndex = programIndex;
    }
    this.catchupParams = { stream: stream, start: startTimestamp, duration: durationMinutes, extension: extension, format: formatIndex };
    var posterUrl = stream ? (stream.stream_icon || stream.cover) : null;
    this.showLoading(true, posterUrl);
    var self = this;
    this.player.onStateChange = function(state) {
        if (state === 'playing') {
            self.streamReady = true;
            self.isBuffering = false;
            self.updatePlayerStateIndicator();
            self.showLoading(false);
            self.showPlayerOverlay();
            // Save working format
            self.settings.catchupFormat = formatIndex;
            self.saveSettings();
            // If coming from previous program (rewind), seek to near end
            if (self.catchupSeekToEnd) {
                self.catchupSeekToEnd = false;
                setTimeout(function() {
                    var endPosition = Math.max(0, self.player.duration - 60000);
                    window.log('Catchup: seeking to end position ' + endPosition);
                    self.player.seekTo(endPosition);
                    self.seekTargetPosition = endPosition;
                }, 1000);
            }
        }
        else if (state === 'buffering') {
            self.isBuffering = true;
            self.updatePlayerStateIndicator();
        }
        else if (state === 'completed') {
            self.playNextCatchup();
        }
    };
    this.player.onTimeUpdate = function(current, total) {
        self.updatePlayerProgress(current, total);
    };
    this.player.onError = function(error) {
        var errorMsg = error ? (error.type || JSON.stringify(error)) : 'unknown';
        window.log('Catchup format ' + formatIndex + ' failed: ' + errorMsg);
        // Find next format to try (0-3 that hasn't been tried yet)
        var nextFormat = -1;
        for (var i = 0; i < 4; i++) {
            if (triedFormats.indexOf(i) === -1) {
                nextFormat = i;
                break;
            }
        }
        if (nextFormat >= 0) {
            window.log('Trying catchup format ' + nextFormat + '...');
            self.playCatchup(stream, startTimestamp, durationMinutes, extension, nextFormat, triedFormats);
        }
        else {
            window.log('All catchup formats failed');
            self.showLoading(false);
            self.showToast(I18n.t('player.playbackError') || 'Playback error');
            setTimeout(function() {
                self.stopPlayback();
            }, 100);
        }
    };
    this.player.play(url, false);
    var title = document.getElementById('player-title-text');
    var progTitle = '';
    var prog = this.catchupPlaylist ? this.catchupPlaylist[this.catchupPlaylistIndex] : null;
    if (prog && prog.title) {
        try {
            progTitle = decodeURIComponent(escape(atob(prog.title)));
        }
        catch (e) {
            progTitle = prog.title;
        }
    }
    title.textContent = this.stripCategoryPrefix(stream.name) + (progTitle ? ' - ' + progTitle : '');
    document.getElementById('player-epg').textContent = '';
};

// Play next catchup program in playlist
IPTVApp.prototype.playNextCatchup = function() {
    if (!this.catchupPlaylist || !this.catchupParams) {
        this.stopPlayback();
        return;
    }
    var nextIndex = this.catchupPlaylistIndex + 1;
    if (nextIndex >= this.catchupPlaylist.length) {
        window.log('Catchup: end of playlist, stopping');
        this.stopPlayback();
        return;
    }
    var prog = this.catchupPlaylist[nextIndex];
    if (!prog) {
        this.stopPlayback();
        return;
    }
    var start = parseInt(prog.start_timestamp, 10);
    var end = parseInt(prog.stop_timestamp, 10);
    var duration = Math.round((end - start) / 60);
    window.log('Catchup: playing next program index=' + nextIndex);
    this.catchupPlaylistIndex = nextIndex;
    this.player.stop();
    this.playCatchup(this.catchupParams.stream, start, duration, this.catchupParams.extension);
};

// Play previous catchup program in playlist (starts near end to simulate continuous rewind)
IPTVApp.prototype.playPrevCatchup = function() {
    if (!this.catchupPlaylist || !this.catchupParams) {
        return false;
    }
    var prevIndex = this.catchupPlaylistIndex - 1;
    if (prevIndex < 0) {
        window.log('Catchup: already at first program');
        return false;
    }
    var prog = this.catchupPlaylist[prevIndex];
    if (!prog) {
        return false;
    }
    var start = parseInt(prog.start_timestamp, 10);
    var end = parseInt(prog.stop_timestamp, 10);
    var duration = Math.round((end - start) / 60);
    window.log('Catchup: playing previous program index=' + prevIndex + ' (starting near end)');
    this.catchupPlaylistIndex = prevIndex;
    // Mark that we need to seek to end once playback starts
    this.catchupSeekToEnd = true;
    this.player.stop();
    this.playCatchup(this.catchupParams.stream, start, duration, this.catchupParams.extension);
    return true;
};
